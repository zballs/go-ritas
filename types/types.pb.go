// Code generated by protoc-gen-go.
// source: types.proto
// DO NOT EDIT!

/*
Package types is a generated protocol buffer package.

It is generated from these files:
	types.proto

It has these top-level messages:
	Payload
	Hashload
	Vector
	HashVector
	Bloom
	Stage
	StageAB
	StageVC
	StageMV
	StageBC
	StageRB
	StageEB
	Stages
	Sender
	Broadcaster
	Message
	MessageProtocol
	MessageAtomic
*/
package types

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Payload struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Payload) Reset()                    { *m = Payload{} }
func (m *Payload) String() string            { return proto.CompactTextString(m) }
func (*Payload) ProtoMessage()               {}
func (*Payload) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Hashload struct {
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *Hashload) Reset()                    { *m = Hashload{} }
func (m *Hashload) String() string            { return proto.CompactTextString(m) }
func (*Hashload) ProtoMessage()               {}
func (*Hashload) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type Vector struct {
	Payloads []*Payload `protobuf:"bytes,1,rep,name=payloads" json:"payloads,omitempty"`
}

func (m *Vector) Reset()                    { *m = Vector{} }
func (m *Vector) String() string            { return proto.CompactTextString(m) }
func (*Vector) ProtoMessage()               {}
func (*Vector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Vector) GetPayloads() []*Payload {
	if m != nil {
		return m.Payloads
	}
	return nil
}

type HashVector struct {
	Hashloads []*Hashload `protobuf:"bytes,1,rep,name=hashloads" json:"hashloads,omitempty"`
}

func (m *HashVector) Reset()                    { *m = HashVector{} }
func (m *HashVector) String() string            { return proto.CompactTextString(m) }
func (*HashVector) ProtoMessage()               {}
func (*HashVector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *HashVector) GetHashloads() []*Hashload {
	if m != nil {
		return m.Hashloads
	}
	return nil
}

type Bloom struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Bloom) Reset()                    { *m = Bloom{} }
func (m *Bloom) String() string            { return proto.CompactTextString(m) }
func (*Bloom) ProtoMessage()               {}
func (*Bloom) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type Stage struct {
	// Types that are valid to be assigned to Value:
	//	*Stage_AB
	//	*Stage_VC
	//	*Stage_MV
	//	*Stage_BC
	//	*Stage_RB
	//	*Stage_EB
	Value isStage_Value `protobuf_oneof:"value"`
}

func (m *Stage) Reset()                    { *m = Stage{} }
func (m *Stage) String() string            { return proto.CompactTextString(m) }
func (*Stage) ProtoMessage()               {}
func (*Stage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type isStage_Value interface {
	isStage_Value()
}

type Stage_AB struct {
	AB *StageAB `protobuf:"bytes,1,opt,name=AB,oneof"`
}
type Stage_VC struct {
	VC *StageVC `protobuf:"bytes,2,opt,name=VC,oneof"`
}
type Stage_MV struct {
	MV *StageMV `protobuf:"bytes,3,opt,name=MV,oneof"`
}
type Stage_BC struct {
	BC *StageBC `protobuf:"bytes,4,opt,name=BC,oneof"`
}
type Stage_RB struct {
	RB *StageRB `protobuf:"bytes,5,opt,name=RB,oneof"`
}
type Stage_EB struct {
	EB *StageEB `protobuf:"bytes,6,opt,name=EB,oneof"`
}

func (*Stage_AB) isStage_Value() {}
func (*Stage_VC) isStage_Value() {}
func (*Stage_MV) isStage_Value() {}
func (*Stage_BC) isStage_Value() {}
func (*Stage_RB) isStage_Value() {}
func (*Stage_EB) isStage_Value() {}

func (m *Stage) GetValue() isStage_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Stage) GetAB() *StageAB {
	if x, ok := m.GetValue().(*Stage_AB); ok {
		return x.AB
	}
	return nil
}

func (m *Stage) GetVC() *StageVC {
	if x, ok := m.GetValue().(*Stage_VC); ok {
		return x.VC
	}
	return nil
}

func (m *Stage) GetMV() *StageMV {
	if x, ok := m.GetValue().(*Stage_MV); ok {
		return x.MV
	}
	return nil
}

func (m *Stage) GetBC() *StageBC {
	if x, ok := m.GetValue().(*Stage_BC); ok {
		return x.BC
	}
	return nil
}

func (m *Stage) GetRB() *StageRB {
	if x, ok := m.GetValue().(*Stage_RB); ok {
		return x.RB
	}
	return nil
}

func (m *Stage) GetEB() *StageEB {
	if x, ok := m.GetValue().(*Stage_EB); ok {
		return x.EB
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Stage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Stage_OneofMarshaler, _Stage_OneofUnmarshaler, _Stage_OneofSizer, []interface{}{
		(*Stage_AB)(nil),
		(*Stage_VC)(nil),
		(*Stage_MV)(nil),
		(*Stage_BC)(nil),
		(*Stage_RB)(nil),
		(*Stage_EB)(nil),
	}
}

func _Stage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Stage)
	// value
	switch x := m.Value.(type) {
	case *Stage_AB:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AB); err != nil {
			return err
		}
	case *Stage_VC:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VC); err != nil {
			return err
		}
	case *Stage_MV:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MV); err != nil {
			return err
		}
	case *Stage_BC:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BC); err != nil {
			return err
		}
	case *Stage_RB:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RB); err != nil {
			return err
		}
	case *Stage_EB:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EB); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Stage.Value has unexpected type %T", x)
	}
	return nil
}

func _Stage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Stage)
	switch tag {
	case 1: // value.AB
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StageAB)
		err := b.DecodeMessage(msg)
		m.Value = &Stage_AB{msg}
		return true, err
	case 2: // value.VC
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StageVC)
		err := b.DecodeMessage(msg)
		m.Value = &Stage_VC{msg}
		return true, err
	case 3: // value.MV
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StageMV)
		err := b.DecodeMessage(msg)
		m.Value = &Stage_MV{msg}
		return true, err
	case 4: // value.BC
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StageBC)
		err := b.DecodeMessage(msg)
		m.Value = &Stage_BC{msg}
		return true, err
	case 5: // value.RB
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StageRB)
		err := b.DecodeMessage(msg)
		m.Value = &Stage_RB{msg}
		return true, err
	case 6: // value.EB
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StageEB)
		err := b.DecodeMessage(msg)
		m.Value = &Stage_EB{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Stage_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Stage)
	// value
	switch x := m.Value.(type) {
	case *Stage_AB:
		s := proto.Size(x.AB)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Stage_VC:
		s := proto.Size(x.VC)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Stage_MV:
		s := proto.Size(x.MV)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Stage_BC:
		s := proto.Size(x.BC)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Stage_RB:
		s := proto.Size(x.RB)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Stage_EB:
		s := proto.Size(x.EB)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type StageAB struct {
	ID    uint32 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Round uint32 `protobuf:"varint,2,opt,name=round" json:"round,omitempty"`
	Step  uint32 `protobuf:"varint,3,opt,name=step" json:"step,omitempty"`
}

func (m *StageAB) Reset()                    { *m = StageAB{} }
func (m *StageAB) String() string            { return proto.CompactTextString(m) }
func (*StageAB) ProtoMessage()               {}
func (*StageAB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type StageVC struct {
	ID    uint32 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Round uint32 `protobuf:"varint,2,opt,name=round" json:"round,omitempty"`
}

func (m *StageVC) Reset()                    { *m = StageVC{} }
func (m *StageVC) String() string            { return proto.CompactTextString(m) }
func (*StageVC) ProtoMessage()               {}
func (*StageVC) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type StageMV struct {
	ID   uint32 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Step uint32 `protobuf:"varint,2,opt,name=step" json:"step,omitempty"`
}

func (m *StageMV) Reset()                    { *m = StageMV{} }
func (m *StageMV) String() string            { return proto.CompactTextString(m) }
func (*StageMV) ProtoMessage()               {}
func (*StageMV) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type StageBC struct {
	ID   uint32 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Step uint32 `protobuf:"varint,2,opt,name=step" json:"step,omitempty"`
}

func (m *StageBC) Reset()                    { *m = StageBC{} }
func (m *StageBC) String() string            { return proto.CompactTextString(m) }
func (*StageBC) ProtoMessage()               {}
func (*StageBC) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type StageRB struct {
	ID   uint32 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Step uint32 `protobuf:"varint,2,opt,name=step" json:"step,omitempty"`
}

func (m *StageRB) Reset()                    { *m = StageRB{} }
func (m *StageRB) String() string            { return proto.CompactTextString(m) }
func (*StageRB) ProtoMessage()               {}
func (*StageRB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type StageEB struct {
	ID   uint32 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Step uint32 `protobuf:"varint,2,opt,name=step" json:"step,omitempty"`
}

func (m *StageEB) Reset()                    { *m = StageEB{} }
func (m *StageEB) String() string            { return proto.CompactTextString(m) }
func (*StageEB) ProtoMessage()               {}
func (*StageEB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type Stages struct {
	AB *Stage `protobuf:"bytes,1,opt,name=AB" json:"AB,omitempty"`
	VC *Stage `protobuf:"bytes,2,opt,name=VC" json:"VC,omitempty"`
	MV *Stage `protobuf:"bytes,3,opt,name=MV" json:"MV,omitempty"`
	BC *Stage `protobuf:"bytes,4,opt,name=BC" json:"BC,omitempty"`
	RB *Stage `protobuf:"bytes,5,opt,name=RB" json:"RB,omitempty"`
	EB *Stage `protobuf:"bytes,6,opt,name=EB" json:"EB,omitempty"`
}

func (m *Stages) Reset()                    { *m = Stages{} }
func (m *Stages) String() string            { return proto.CompactTextString(m) }
func (*Stages) ProtoMessage()               {}
func (*Stages) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Stages) GetAB() *Stage {
	if m != nil {
		return m.AB
	}
	return nil
}

func (m *Stages) GetVC() *Stage {
	if m != nil {
		return m.VC
	}
	return nil
}

func (m *Stages) GetMV() *Stage {
	if m != nil {
		return m.MV
	}
	return nil
}

func (m *Stages) GetBC() *Stage {
	if m != nil {
		return m.BC
	}
	return nil
}

func (m *Stages) GetRB() *Stage {
	if m != nil {
		return m.RB
	}
	return nil
}

func (m *Stages) GetEB() *Stage {
	if m != nil {
		return m.EB
	}
	return nil
}

type Sender struct {
	ID   uint32 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Addr string `protobuf:"bytes,2,opt,name=addr" json:"addr,omitempty"`
}

func (m *Sender) Reset()                    { *m = Sender{} }
func (m *Sender) String() string            { return proto.CompactTextString(m) }
func (*Sender) ProtoMessage()               {}
func (*Sender) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

type Broadcaster struct {
	ID   uint32 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Addr string `protobuf:"bytes,2,opt,name=addr" json:"addr,omitempty"`
}

func (m *Broadcaster) Reset()                    { *m = Broadcaster{} }
func (m *Broadcaster) String() string            { return proto.CompactTextString(m) }
func (*Broadcaster) ProtoMessage()               {}
func (*Broadcaster) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type Message struct {
	// Types that are valid to be assigned to Value:
	//	*Message_Protocol
	//	*Message_Atomic
	Value isMessage_Value `protobuf_oneof:"value"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type isMessage_Value interface {
	isMessage_Value()
}

type Message_Protocol struct {
	Protocol *MessageProtocol `protobuf:"bytes,1,opt,name=protocol,oneof"`
}
type Message_Atomic struct {
	Atomic *MessageAtomic `protobuf:"bytes,2,opt,name=atomic,oneof"`
}

func (*Message_Protocol) isMessage_Value() {}
func (*Message_Atomic) isMessage_Value()   {}

func (m *Message) GetValue() isMessage_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Message) GetProtocol() *MessageProtocol {
	if x, ok := m.GetValue().(*Message_Protocol); ok {
		return x.Protocol
	}
	return nil
}

func (m *Message) GetAtomic() *MessageAtomic {
	if x, ok := m.GetValue().(*Message_Atomic); ok {
		return x.Atomic
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Message) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Message_OneofMarshaler, _Message_OneofUnmarshaler, _Message_OneofSizer, []interface{}{
		(*Message_Protocol)(nil),
		(*Message_Atomic)(nil),
	}
}

func _Message_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Message)
	// value
	switch x := m.Value.(type) {
	case *Message_Protocol:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Protocol); err != nil {
			return err
		}
	case *Message_Atomic:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Atomic); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Message.Value has unexpected type %T", x)
	}
	return nil
}

func _Message_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Message)
	switch tag {
	case 1: // value.protocol
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MessageProtocol)
		err := b.DecodeMessage(msg)
		m.Value = &Message_Protocol{msg}
		return true, err
	case 2: // value.atomic
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MessageAtomic)
		err := b.DecodeMessage(msg)
		m.Value = &Message_Atomic{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Message_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Message)
	// value
	switch x := m.Value.(type) {
	case *Message_Protocol:
		s := proto.Size(x.Protocol)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_Atomic:
		s := proto.Size(x.Atomic)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type MessageProtocol struct {
	Stage       *Stage       `protobuf:"bytes,1,opt,name=stage" json:"stage,omitempty"`
	Payload     *Payload     `protobuf:"bytes,2,opt,name=payload" json:"payload,omitempty"`
	Vector      *Vector      `protobuf:"bytes,3,opt,name=vector" json:"vector,omitempty"`
	Stages      *Stages      `protobuf:"bytes,4,opt,name=stages" json:"stages,omitempty"`
	Sender      *Sender      `protobuf:"bytes,5,opt,name=sender" json:"sender,omitempty"`
	Broadcaster *Broadcaster `protobuf:"bytes,6,opt,name=broadcaster" json:"broadcaster,omitempty"`
}

func (m *MessageProtocol) Reset()                    { *m = MessageProtocol{} }
func (m *MessageProtocol) String() string            { return proto.CompactTextString(m) }
func (*MessageProtocol) ProtoMessage()               {}
func (*MessageProtocol) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *MessageProtocol) GetStage() *Stage {
	if m != nil {
		return m.Stage
	}
	return nil
}

func (m *MessageProtocol) GetPayload() *Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *MessageProtocol) GetVector() *Vector {
	if m != nil {
		return m.Vector
	}
	return nil
}

func (m *MessageProtocol) GetStages() *Stages {
	if m != nil {
		return m.Stages
	}
	return nil
}

func (m *MessageProtocol) GetSender() *Sender {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *MessageProtocol) GetBroadcaster() *Broadcaster {
	if m != nil {
		return m.Broadcaster
	}
	return nil
}

type MessageAtomic struct {
	Payload *Payload `protobuf:"bytes,1,opt,name=payload" json:"payload,omitempty"`
	Stages  *Stages  `protobuf:"bytes,2,opt,name=stages" json:"stages,omitempty"`
	Sender  *Sender  `protobuf:"bytes,3,opt,name=sender" json:"sender,omitempty"`
}

func (m *MessageAtomic) Reset()                    { *m = MessageAtomic{} }
func (m *MessageAtomic) String() string            { return proto.CompactTextString(m) }
func (*MessageAtomic) ProtoMessage()               {}
func (*MessageAtomic) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *MessageAtomic) GetPayload() *Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *MessageAtomic) GetStages() *Stages {
	if m != nil {
		return m.Stages
	}
	return nil
}

func (m *MessageAtomic) GetSender() *Sender {
	if m != nil {
		return m.Sender
	}
	return nil
}

func init() {
	proto.RegisterType((*Payload)(nil), "types.Payload")
	proto.RegisterType((*Hashload)(nil), "types.Hashload")
	proto.RegisterType((*Vector)(nil), "types.Vector")
	proto.RegisterType((*HashVector)(nil), "types.HashVector")
	proto.RegisterType((*Bloom)(nil), "types.Bloom")
	proto.RegisterType((*Stage)(nil), "types.Stage")
	proto.RegisterType((*StageAB)(nil), "types.StageAB")
	proto.RegisterType((*StageVC)(nil), "types.StageVC")
	proto.RegisterType((*StageMV)(nil), "types.StageMV")
	proto.RegisterType((*StageBC)(nil), "types.StageBC")
	proto.RegisterType((*StageRB)(nil), "types.StageRB")
	proto.RegisterType((*StageEB)(nil), "types.StageEB")
	proto.RegisterType((*Stages)(nil), "types.Stages")
	proto.RegisterType((*Sender)(nil), "types.Sender")
	proto.RegisterType((*Broadcaster)(nil), "types.Broadcaster")
	proto.RegisterType((*Message)(nil), "types.Message")
	proto.RegisterType((*MessageProtocol)(nil), "types.MessageProtocol")
	proto.RegisterType((*MessageAtomic)(nil), "types.MessageAtomic")
}

func init() { proto.RegisterFile("types.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 566 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x94, 0xc1, 0x6a, 0xdb, 0x40,
	0x10, 0x86, 0x2d, 0x39, 0x92, 0x9d, 0x71, 0x94, 0xc0, 0x12, 0x8a, 0xa0, 0x69, 0x31, 0x0b, 0x05,
	0x53, 0x1a, 0x97, 0xb6, 0xbe, 0xf5, 0xe4, 0x55, 0x0c, 0xce, 0x41, 0x10, 0x36, 0xb0, 0xf7, 0x8d,
	0x25, 0xea, 0x82, 0x13, 0x19, 0xad, 0x12, 0x9a, 0x27, 0x28, 0xf4, 0x99, 0xfa, 0x28, 0x7d, 0x98,
	0xb2, 0xe3, 0x91, 0x2c, 0x4b, 0xa6, 0x75, 0x6e, 0x6b, 0xff, 0xdf, 0xcc, 0xce, 0xec, 0x3f, 0x1a,
	0x18, 0x14, 0xcf, 0xeb, 0xd4, 0x8c, 0xd7, 0x79, 0x56, 0x64, 0xcc, 0xc3, 0x1f, 0xfc, 0x0d, 0xf4,
	0x6e, 0xf4, 0xf3, 0x2a, 0xd3, 0x09, 0x63, 0x70, 0x94, 0xe8, 0x42, 0x87, 0xce, 0xd0, 0x19, 0x9d,
	0x48, 0x3c, 0xf3, 0xb7, 0xd0, 0x9f, 0x6b, 0xb3, 0x2c, 0xf5, 0xa5, 0x36, 0xcb, 0x52, 0xb7, 0x67,
	0x3e, 0x01, 0x5f, 0xa5, 0x8b, 0x22, 0xcb, 0xd9, 0x7b, 0xe8, 0xaf, 0x37, 0x89, 0x4c, 0xe8, 0x0c,
	0xbb, 0xa3, 0xc1, 0xe7, 0xd3, 0xf1, 0xe6, 0x3e, 0xca, 0x2f, 0x2b, 0x9d, 0x7f, 0x05, 0xb0, 0x59,
	0x29, 0xf2, 0x12, 0x8e, 0x97, 0x74, 0x47, 0x19, 0x7a, 0x46, 0xa1, 0xe5, 0xdd, 0x72, 0x4b, 0xf0,
	0xd7, 0xe0, 0x89, 0x55, 0x96, 0xdd, 0xef, 0xad, 0xf7, 0x8f, 0x03, 0xde, 0x6d, 0xa1, 0xbf, 0xa5,
	0x6c, 0x08, 0xee, 0x54, 0xa0, 0xb6, 0xad, 0x04, 0x95, 0xa9, 0x98, 0x77, 0xa4, 0x3b, 0x15, 0x96,
	0x50, 0x51, 0xe8, 0xb6, 0x09, 0x15, 0x59, 0x42, 0x45, 0x96, 0x88, 0x55, 0xd8, 0x6d, 0x13, 0xb1,
	0xb2, 0x44, 0xac, 0x2c, 0x21, 0xa2, 0xf0, 0xa8, 0x4d, 0x08, 0xcc, 0x21, 0x30, 0x87, 0x14, 0xa1,
	0xd7, 0x26, 0x24, 0xd6, 0x21, 0xb1, 0x8e, 0x99, 0x08, 0xfd, 0x36, 0x31, 0x43, 0x62, 0x26, 0x44,
	0x0f, 0xbc, 0x27, 0xbd, 0x7a, 0x4c, 0x79, 0x04, 0x3d, 0xea, 0x81, 0x9d, 0x82, 0x7b, 0x7d, 0x85,
	0xfd, 0x05, 0xd2, 0xbd, 0xbe, 0x62, 0xe7, 0xe0, 0xe5, 0xd9, 0xe3, 0x43, 0x82, 0x0d, 0x05, 0x72,
	0xf3, 0xc3, 0xbe, 0x91, 0x29, 0xd2, 0x35, 0xf6, 0x10, 0x48, 0x3c, 0xf3, 0x8f, 0x94, 0x44, 0x45,
	0x87, 0x25, 0xe1, 0x97, 0x14, 0x10, 0xab, 0x56, 0x40, 0x99, 0xdf, 0xad, 0xe5, 0x2f, 0x71, 0x11,
	0xbd, 0x08, 0x97, 0xe2, 0x45, 0xf8, 0xec, 0x30, 0xfc, 0xb7, 0x03, 0x3e, 0xf2, 0x86, 0x5d, 0xd4,
	0x26, 0xe2, 0x64, 0xc7, 0x09, 0x3b, 0x0d, 0x17, 0xb5, 0x69, 0x68, 0xa8, 0x2a, 0xb2, 0x6a, 0x35,
	0x09, 0x0d, 0x35, 0x56, 0x56, 0xad, 0xa6, 0xa0, 0xa1, 0x0a, 0x8c, 0xad, 0x26, 0xa0, 0xa1, 0x4a,
	0xbc, 0xb7, 0x72, 0xbf, 0xa1, 0xce, 0x04, 0xff, 0x00, 0xfe, 0x6d, 0xfa, 0x90, 0xa4, 0xf9, 0xbe,
	0x66, 0x75, 0x92, 0xe4, 0x58, 0xf1, 0xb1, 0xc4, 0x33, 0xff, 0x04, 0x03, 0x91, 0x67, 0x3a, 0x59,
	0x68, 0x53, 0x1c, 0x18, 0xf2, 0x03, 0x7a, 0x71, 0x6a, 0x8c, 0xfd, 0x62, 0x26, 0xd0, 0xc7, 0xd5,
	0xb0, 0xc8, 0x56, 0xf4, 0x4a, 0xaf, 0xa8, 0x1e, 0x22, 0x6e, 0x48, 0x9d, 0x77, 0x64, 0x45, 0xb2,
	0x31, 0xf8, 0xba, 0xc8, 0xee, 0xbf, 0x2f, 0xe8, 0xed, 0xce, 0x77, 0x63, 0xa6, 0xa8, 0xcd, 0x3b,
	0x92, 0xa8, 0xed, 0x2c, 0xff, 0x72, 0xe1, 0xac, 0x91, 0x98, 0x71, 0xf0, 0x8c, 0xed, 0x7d, 0xaf,
	0x4b, 0x1b, 0x89, 0x8d, 0xa0, 0x47, 0x8b, 0xa4, 0xf1, 0xed, 0x96, 0x7b, 0xa6, 0x94, 0xd9, 0x3b,
	0xf0, 0x9f, 0x70, 0xc5, 0x90, 0x71, 0x01, 0x81, 0x9b, 0xbd, 0x23, 0x49, 0xb4, 0x18, 0x66, 0x36,
	0xe4, 0x60, 0x50, 0xbf, 0xd5, 0x48, 0x12, 0x11, 0x43, 0x2b, 0xc8, 0xca, 0x0a, 0xc3, 0x3f, 0x25,
	0x89, 0x6c, 0x02, 0x83, 0xbb, 0xad, 0x07, 0x64, 0x2c, 0x23, 0xb6, 0xe6, 0x8e, 0xac, 0x63, 0xfc,
	0xa7, 0x03, 0xc1, 0xce, 0x8b, 0xd5, 0xdb, 0x74, 0xfe, 0xdb, 0x26, 0xd5, 0xef, 0x1e, 0x56, 0x7f,
	0xf7, 0x1f, 0xf5, 0xdf, 0xf9, 0xe8, 0xec, 0x97, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x3c, 0x32,
	0xa2, 0xdf, 0x2d, 0x06, 0x00, 0x00,
}
